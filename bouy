#!/bin/bash
set -e

# Bouy - Docker fleet management for Pantry Pirate Radio
# Navigate the seas of containers with ease!
#
# Version: 1.0.0
#
COMPOSE_FILES="-f docker-compose.yml"
COMPOSE_CMD="docker compose"
VERSION="1.0.0"

# Default behavior flags
PROGRAMMATIC_MODE=0
VERBOSE=0
QUIET=0
JSON_OUTPUT=0
NO_COLOR=0

# Parse global flags
while [[ $# -gt 0 ]] && [[ "$1" =~ ^-- ]]; do
    case $1 in
        --version|-v)
            echo "⚓ Bouy v$VERSION"
            echo "Docker fleet management for Pantry Pirate Radio"
            exit 0
            ;;
        --programmatic)
            PROGRAMMATIC_MODE=1
            NO_COLOR=1
            shift
            ;;
        --json)
            JSON_OUTPUT=1
            PROGRAMMATIC_MODE=1
            NO_COLOR=1
            shift
            ;;
        --verbose)
            VERBOSE=1
            shift
            ;;
        --quiet)
            QUIET=1
            shift
            ;;
        --no-color)
            NO_COLOR=1
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            break
            ;;
    esac
done

# Output functions for programmatic mode
output() {
    local level="$1"
    local message="$2"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    if [ $QUIET -eq 1 ] && [ "$level" != "error" ] && [ "$level" != "result" ]; then
        return
    fi

    if [ $JSON_OUTPUT -eq 1 ]; then
        # Escape quotes in message for JSON
        message="${message//\"/\\\"}"
        echo "{\"timestamp\":\"$timestamp\",\"level\":\"$level\",\"message\":\"$message\"}"
    elif [ $PROGRAMMATIC_MODE -eq 1 ]; then
        echo "[$timestamp] [$level] $message" >&2
    elif [ "$level" = "result" ]; then
        # Results always go to stdout
        echo "$message"
    else
        # Normal mode - colored output to stderr
        if [ $NO_COLOR -eq 0 ]; then
            case "$level" in
                error)
                    echo -e "\033[31m[ERROR]\033[0m $message" >&2
                    ;;
                warning)
                    echo -e "\033[33m[WARNING]\033[0m $message" >&2
                    ;;
                info)
                    echo -e "\033[34m[INFO]\033[0m $message" >&2
                    ;;
                success)
                    echo -e "\033[32m[SUCCESS]\033[0m $message" >&2
                    ;;
                *)
                    echo "$message" >&2
                    ;;
            esac
        else
            echo "[$level] $message" >&2
        fi
    fi
}

# Function to show usage
usage() {
    echo "⚓ Bouy v$VERSION - Docker Fleet Management ⚓"
    echo ""
    echo "Usage: bouy [GLOBAL_OPTIONS] COMMAND [OPTIONS]"
    echo ""
    echo "Global Options:"
    echo "  --programmatic      Enable programmatic mode (structured output)"
    echo "  --json              Output in JSON format (implies --programmatic)"
    echo "  --verbose           Enable verbose output"
    echo "  --quiet             Suppress non-error output"
    echo "  --no-color          Disable colored output"
    echo ""
    echo "Commands:"
    echo "  up [SERVICE]        Start services (dev mode by default)"
    echo "  down                Stop all services"
    echo "  build [SERVICE]     Build services"
    echo "  logs [SERVICE]      View logs (follows by default)"
    echo "  shell SERVICE       Open shell in service container"
    echo "  exec SERVICE CMD    Execute command in service container"
    echo "  ps                  List running services"
    echo "  test [OPTIONS]      Run tests with various options"
    echo "  scraper [NAME|--all] Run specific scraper or all scrapers"
    echo "  claude-auth [CMD]   Manage Claude authentication"
    echo "  reconciler [ARGS]   Run the reconciler service"
    echo "  recorder [ARGS]     Run the recorder service"
    echo "  content-store [CMD] Manage content store"
    echo "  haarrrvest [CMD]    Manage HAARRRvest publisher"
    echo "  clean               Stop services and remove volumes"
    echo ""
    echo "Test options:"
    echo "  test                Run all CI checks"
    echo "  test --pytest       Run only pytest"
    echo "  test --mypy         Run only mypy type checking"
    echo "  test --black        Run only black formatting"
    echo "  test --ruff         Run only ruff linting"
    echo "  test --bandit       Run only bandit security check"
    echo "  test --coverage     Run pytest with coverage"
    echo ""
    echo "Scraper options:"
    echo "  scraper --list      List all available scrapers"
    echo "  scraper --all       Run all scrapers"
    echo "  scraper NAME        Run specific scraper by name"
    echo ""
    echo "Claude auth options:"
    echo "  claude-auth         Interactive Claude authentication"
    echo "  claude-auth setup   Setup Claude authentication"
    echo "  claude-auth status  Check authentication status"
    echo "  claude-auth test    Test Claude connection"
    echo "  claude-auth config  Show Claude configuration"
    echo ""
    echo "Content store options:"
    echo "  content-store status      Show content store status"
    echo "  content-store report      Generate detailed report"
    echo "  content-store duplicates  Find duplicate content"
    echo "  content-store efficiency  Analyze storage efficiency"
    echo ""
    echo "HAARRRvest publisher options:"
    echo "  haarrrvest              Manually trigger publishing run"
    echo "  haarrrvest run          Manually trigger publishing run"
    echo "  haarrrvest logs         Follow publisher logs"
    echo "  haarrrvest status       Check publisher service status"
    echo ""
    echo "Environment modes (use with 'up'):"
    echo "  --dev               Development mode (default)"
    echo "  --prod              Production mode"
    echo "  --test              Test mode"
    echo "  --with-init         Include database initialization"
    echo ""
    echo "Examples:"
    echo "  bouy up                    # Start dev environment"
    echo "  bouy up --prod             # Start production environment"
    echo "  bouy up worker --dev       # Start only worker in dev mode"
    echo "  bouy logs app              # View app logs"
    echo "  bouy shell app             # Open shell in app container"
    echo "  bouy test                  # Run tests"
    echo ""
    echo "Programmatic Examples:"
    echo "  bouy --json ps             # Get service status as JSON"
    echo "  bouy --quiet up            # Start services with minimal output"
    echo "  bouy --programmatic exec app python --version"
    echo ""
    echo "⛵ Smooth sailing with your container fleet!"
}

# Parse environment mode
parse_mode() {
    local mode="dev"
    for arg in "$@"; do
        case $arg in
            --dev)
                mode="dev"
                ;;
            --prod)
                mode="prod"
                ;;
            --test)
                mode="test"
                ;;
            --with-init)
                COMPOSE_FILES="$COMPOSE_FILES -f .docker/compose/docker-compose.with-init.yml"
                ;;
        esac
    done

    case $mode in
        dev)
            COMPOSE_FILES="$COMPOSE_FILES -f .docker/compose/docker-compose.dev.yml"
            ;;
        prod)
            COMPOSE_FILES="$COMPOSE_FILES -f .docker/compose/docker-compose.prod.yml"
            ;;
        test)
            COMPOSE_FILES="$COMPOSE_FILES -f .docker/compose/docker-compose.test.yml"
            ;;
    esac
}

# Main command handling
case "$1" in
    up)
        shift
        parse_mode "$@"
        # Filter out mode flags from service names
        services=""
        for arg in "$@"; do
            case $arg in
                --dev|--prod|--test|--with-init)
                    ;;
                *)
                    services="$services $arg"
                    ;;
            esac
        done

        output info "Starting services with: $COMPOSE_CMD $COMPOSE_FILES"
        # Check if --with-init was used
        if [[ "$COMPOSE_FILES" == *"with-init"* ]]; then
            if $COMPOSE_CMD $COMPOSE_FILES --profile with-init up -d $services; then
                output success "Services started successfully"
            else
                output error "Failed to start services"
                exit 1
            fi
        else
            if $COMPOSE_CMD $COMPOSE_FILES up -d $services; then
                output success "Services started successfully"
            else
                output error "Failed to start services"
                exit 1
            fi
        fi

        # Show status
        if [ $PROGRAMMATIC_MODE -eq 0 ]; then
            echo ""
            $COMPOSE_CMD $COMPOSE_FILES ps
            echo ""
            echo "Services started! Access points:"
            echo "  - API: http://localhost:8000"
            echo "  - API Docs: http://localhost:8000/docs"
            echo "  - Datasette: http://localhost:8001"
            echo "  - RQ Dashboard: http://localhost:9181"
        else
            # In programmatic mode, output JSON with service URLs
            if [ $JSON_OUTPUT -eq 1 ]; then
                echo '{"status":"started","endpoints":{"api":"http://localhost:8000","docs":"http://localhost:8000/docs","datasette":"http://localhost:8001","rq_dashboard":"http://localhost:9181"}}'
            fi
        fi
        ;;

    down)
        output info "Stopping all services..."
        if $COMPOSE_CMD $COMPOSE_FILES down; then
            output success "All services stopped"
        else
            output error "Failed to stop services"
            exit 1
        fi
        ;;

    build)
        shift
        parse_mode "$@"
        services=""
        for arg in "$@"; do
            case $arg in
                --dev|--prod|--test|--with-init)
                    ;;
                *)
                    services="$services $arg"
                    ;;
            esac
        done
        output info "Building services..."
        if $COMPOSE_CMD $COMPOSE_FILES build $services; then
            output success "Build complete"
        else
            output error "Build failed"
            exit 1
        fi
        ;;

    logs)
        shift
        parse_mode "$@"
        service="$1"

        # In programmatic mode, don't follow logs by default
        LOG_FLAGS="-f"
        if [ $PROGRAMMATIC_MODE -eq 1 ]; then
            LOG_FLAGS="--tail 100"
        fi

        if [ -z "$service" ]; then
            $COMPOSE_CMD $COMPOSE_FILES logs $LOG_FLAGS
        else
            $COMPOSE_CMD $COMPOSE_FILES logs $LOG_FLAGS "$service"
        fi
        ;;

    shell)
        shift
        parse_mode "$@"
        service="$1"
        if [ -z "$service" ]; then
            output error "Please specify a service name"
            output error "Example: ./docker.sh shell app"
            exit 1
        fi
        if [ $PROGRAMMATIC_MODE -eq 1 ]; then
            output error "Shell command requires interactive mode. Run without --programmatic flag."
            exit 1
        fi
        $COMPOSE_CMD $COMPOSE_FILES exec "$service" bash || \
        $COMPOSE_CMD $COMPOSE_FILES exec "$service" sh
        ;;

    exec)
        shift
        parse_mode "$@"
        service="$1"
        shift
        if [ -z "$service" ]; then
            output error "Please specify a service name and command"
            output error "Example: ./docker.sh exec app python --version"
            exit 1
        fi
        EXEC_FLAGS=""
        if [ $PROGRAMMATIC_MODE -eq 1 ]; then
            EXEC_FLAGS="-T"
        fi
        $COMPOSE_CMD $COMPOSE_FILES exec $EXEC_FLAGS "$service" "$@"
        ;;

    ps)
        parse_mode "$@"
        if [ $JSON_OUTPUT -eq 1 ]; then
            # Try to use docker compose ps --format json if available
            if $COMPOSE_CMD $COMPOSE_FILES ps --format json 2>/dev/null; then
                :
            else
                # Fallback: parse regular output into JSON
                output warning "JSON format not supported by this docker compose version"
                $COMPOSE_CMD $COMPOSE_FILES ps
            fi
        else
            $COMPOSE_CMD $COMPOSE_FILES ps
        fi
        ;;

    test)
        shift
        test_cmd=""

        # Parse test options
        case "${1:-all}" in
            --pytest)
                test_cmd="poetry run pytest --ignore=docs --ignore=tests/test_integration --cov=app --cov-report=term-missing --cov-report=xml --cov-report=json --cov-branch"
                ;;
            --mypy)
                test_cmd="poetry run mypy app tests"
                ;;
            --black)
                test_cmd="poetry run black app tests"
                ;;
            --ruff)
                test_cmd="poetry run ruff check app tests"
                ;;
            --bandit)
                test_cmd="poetry run bandit -r app"
                ;;
            --coverage)
                test_cmd="poetry run pytest --ignore=docs --ignore=tests/test_integration --cov=app --cov-report=term-missing --cov-report=xml --cov-report=json --cov-branch && bash scripts/coverage-check.sh"
                ;;
            all|"")
                test_cmd="bash scripts/run-ci-checks.sh"
                ;;
            *)
                output error "Unknown test option: $1"
                output error "Use: test [--pytest|--mypy|--black|--ruff|--bandit|--coverage]"
                exit 1
                ;;
        esac

        output info "Running tests with bind-mounted code..."

        # Ensure the test image is built
        if ! docker image inspect pantry-pirate-radio-test:latest &> /dev/null; then
            output info "Building test image..."
            
            # Use buildx with cache if available
            BUILD_CMD="docker build"
            if command -v docker buildx &> /dev/null; then
                BUILD_CMD="docker buildx build --load"
            fi
            
            if ! $BUILD_CMD -f .docker/images/app/Dockerfile --target test -t pantry-pirate-radio-test:latest .; then
                output error "Failed to build test image"
                exit 1
            fi
        else
            output info "Test image already exists, skipping build"
        fi

        # Use test environment file
        if [ ! -f .env.test ]; then
            output error ".env.test file not found!"
            output error "Please ensure .env.test exists with proper test database configuration."
            exit 1
        fi

        # Start test services if not already running
        output info "Ensuring test services are running..."
        
        # Start services
        output info "Starting database and cache services..."
        $COMPOSE_CMD $COMPOSE_FILES up -d db cache
        
        # Wait for PostgreSQL to be ready
        output info "Waiting for database to be ready..."
        max_attempts=30
        attempt=0
        while [ $attempt -lt $max_attempts ]; do
            if $COMPOSE_CMD $COMPOSE_FILES exec -T db pg_isready -U postgres >/dev/null 2>&1; then
                output info "Database is ready!"
                break
            fi
            attempt=$((attempt + 1))
            if [ $attempt -eq $max_attempts ]; then
                output error "Database failed to become ready"
                $COMPOSE_CMD $COMPOSE_FILES ps
                $COMPOSE_CMD $COMPOSE_FILES logs db --tail 50
                exit 1
            fi
            echo "Waiting for database... (attempt $attempt/$max_attempts)"
            sleep 2
        done
        
        # Wait for Redis to be ready
        output info "Waiting for cache to be ready..."
        attempt=0
        while [ $attempt -lt $max_attempts ]; do
            if $COMPOSE_CMD $COMPOSE_FILES exec -T cache redis-cli ping >/dev/null 2>&1; then
                output info "Cache is ready!"
                break
            fi
            attempt=$((attempt + 1))
            if [ $attempt -eq $max_attempts ]; then
                output error "Cache failed to become ready"
                $COMPOSE_CMD $COMPOSE_FILES ps
                $COMPOSE_CMD $COMPOSE_FILES logs cache --tail 50
                exit 1
            fi
            echo "Waiting for cache... (attempt $attempt/$max_attempts)"
            sleep 2
        done
        
        # Create test database
        output info "Creating test database..."
        $COMPOSE_CMD $COMPOSE_FILES exec -T db psql -U postgres -c "CREATE DATABASE test_pantry_pirate_radio;" 2>/dev/null || true

        # Check if we're in a TTY (disable TTY in programmatic mode)
        TTY_FLAG=""
        if [ -t 0 ] && [ $PROGRAMMATIC_MODE -eq 0 ]; then
            TTY_FLAG="-it"
        fi

        # Get the network name
        NETWORK_NAME="${COMPOSE_PROJECT_NAME:-pantry-pirate-radio}_default"
        
        # Run tests in a temporary container with current code mounted
        docker run --rm $TTY_FLAG \
            -v $(pwd):/app:cached \
            -w /app \
            --network "$NETWORK_NAME" \
            --env-file .env.test \
            -e TEST_DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD:-pirate}@db:5432/test_pantry_pirate_radio \
            -e TEST_REDIS_URL=redis://cache:6379/1 \
            pantry-pirate-radio-test:latest \
            bash -c "$test_cmd"
        ;;

    scraper)
        shift
        parse_mode "$@"

        # Check if scraper service is running
        if ! $COMPOSE_CMD $COMPOSE_FILES ps scraper 2>/dev/null | grep -q "Up"; then
            output info "Scraper service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d scraper; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start scraper service"
                exit 1
            fi
        fi

        # Parse scraper options
        case "${1:-help}" in
            --list)
                output info "Listing available scrapers..."
                # Use -T flag to disable TTY in programmatic mode
                EXEC_FLAGS=""
                if [ $PROGRAMMATIC_MODE -eq 1 ]; then
                    EXEC_FLAGS="-T"
                fi
                $COMPOSE_CMD $COMPOSE_FILES exec $EXEC_FLAGS scraper python -m app.scraper --list
                ;;
            --all)
                output info "Running all scrapers..."
                EXEC_FLAGS=""
                if [ $PROGRAMMATIC_MODE -eq 1 ]; then
                    EXEC_FLAGS="-T"
                fi
                $COMPOSE_CMD $COMPOSE_FILES exec $EXEC_FLAGS scraper python -m app.scraper --all
                ;;
            help|"")
                if [ $PROGRAMMATIC_MODE -eq 0 ]; then
                    echo "Usage: ./docker.sh scraper [--list|--all|SCRAPER_NAME]"
                    echo ""
                    echo "Available scrapers:"
                    $COMPOSE_CMD $COMPOSE_FILES exec scraper python -m app.scraper --list
                else
                    output error "No scraper command specified. Use --list, --all, or provide a scraper name."
                    exit 1
                fi
                ;;
            *)
                # Filter out mode flags
                scraper_name=""
                for arg in "$@"; do
                    case $arg in
                        --dev|--prod|--test|--with-init)
                            ;;
                        *)
                            scraper_name="$arg"
                            break
                            ;;
                    esac
                done

                if [ -n "$scraper_name" ]; then
                    output info "Running scraper: $scraper_name"
                    EXEC_FLAGS=""
                    if [ $PROGRAMMATIC_MODE -eq 1 ]; then
                        EXEC_FLAGS="-T"
                    fi
                    $COMPOSE_CMD $COMPOSE_FILES exec $EXEC_FLAGS scraper python -m app.scraper "$scraper_name"
                else
                    output error "No scraper name provided"
                    exit 1
                fi
                ;;
        esac
        ;;

    claude-auth)
        shift
        parse_mode "$@"

        # Check if worker service is running
        if ! $COMPOSE_CMD $COMPOSE_FILES ps worker 2>/dev/null | grep -q "Up"; then
            output info "Worker service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d worker; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start worker service"
                exit 1
            fi
        fi

        # Parse subcommand
        case "${1:-interactive}" in
            interactive|"")
                if [ $PROGRAMMATIC_MODE -eq 1 ]; then
                    output error "Claude authentication requires interactive mode. Run without --programmatic flag."
                    exit 1
                fi
                output info "Authenticating Claude in worker container..."
                output info "This will open an interactive Claude authentication session."
                echo ""
                $COMPOSE_CMD $COMPOSE_FILES exec worker claude
                ;;
            setup)
                output info "Setting up Claude authentication..."
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.claude_auth_manager setup
                ;;
            status)
                output info "Checking Claude authentication status..."
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.claude_auth_manager status
                ;;
            test)
                output info "Testing Claude authentication..."
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.claude_auth_manager test
                ;;
            config)
                output info "Showing Claude configuration..."
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.claude_auth_manager config
                ;;
            *)
                output error "Unknown claude-auth subcommand: $1"
                output error "Use: claude-auth [interactive|setup|status|test|config]"
                exit 1
                ;;
        esac
        ;;

    reconciler)
        shift
        parse_mode "$@"

        # Check if reconciler service is running
        if ! $COMPOSE_CMD $COMPOSE_FILES ps reconciler 2>/dev/null | grep -q "Up"; then
            output info "Reconciler service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d reconciler; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start reconciler service"
                exit 1
            fi
        fi

        # Build command
        cmd="python -m app.reconciler"
        for arg in "$@"; do
            case $arg in
                --dev|--prod|--test|--with-init)
                    ;;
                *)
                    cmd="$cmd $arg"
                    ;;
            esac
        done

        output info "Running reconciler..."
        EXEC_FLAGS=""
        if [ $PROGRAMMATIC_MODE -eq 1 ]; then
            EXEC_FLAGS="-T"
        fi
        $COMPOSE_CMD $COMPOSE_FILES exec $EXEC_FLAGS reconciler bash -c "$cmd"
        ;;

    recorder)
        shift
        parse_mode "$@"

        # Check if recorder service is running
        if ! $COMPOSE_CMD $COMPOSE_FILES ps recorder 2>/dev/null | grep -q "Up"; then
            output info "Recorder service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d recorder; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start recorder service"
                exit 1
            fi
        fi

        # Build command
        cmd="python -m app.recorder"
        for arg in "$@"; do
            case $arg in
                --dev|--prod|--test|--with-init)
                    ;;
                *)
                    cmd="$cmd $arg"
                    ;;
            esac
        done

        output info "Running recorder..."
        EXEC_FLAGS=""
        if [ $PROGRAMMATIC_MODE -eq 1 ]; then
            EXEC_FLAGS="-T"
        fi
        $COMPOSE_CMD $COMPOSE_FILES exec $EXEC_FLAGS recorder bash -c "$cmd"
        ;;

    content-store)
        shift
        parse_mode "$@"

        # Content store commands run in worker container
        if ! $COMPOSE_CMD $COMPOSE_FILES ps worker 2>/dev/null | grep -q "Up"; then
            output info "Worker service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d worker; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start worker service"
                exit 1
            fi
        fi

        # Parse subcommand
        subcmd="${1:-status}"
        shift || true

        case "$subcmd" in
            status)
                output info "Checking content store status..."
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.content_store status
                ;;
            report)
                output info "Generating content store report..."
                # Pass through any additional arguments
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.content_store report "$@"
                ;;
            duplicates)
                output info "Finding content store duplicates..."
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.content_store duplicates
                ;;
            efficiency)
                output info "Analyzing content store efficiency..."
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.content_store efficiency
                ;;
            *)
                output error "Unknown content-store subcommand: $subcmd"
                output error "Use: content-store [status|report|duplicates|efficiency]"
                exit 1
                ;;
        esac
        ;;

    haarrrvest|publisher)
        shift
        parse_mode "$@"

        # Check if haarrrvest-publisher service is running
        if ! $COMPOSE_CMD $COMPOSE_FILES ps haarrrvest-publisher 2>/dev/null | grep -q "Up"; then
            output info "HAARRRvest publisher service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d haarrrvest-publisher; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start HAARRRvest publisher service"
                exit 1
            fi
        fi

        # Parse subcommand
        case "${1:-run}" in
            run|"")
                output info "Manually triggering HAARRRvest publisher..."
                output info "This will process all pending recorder outputs and push to HAARRRvest repository."
                # Run the publisher module directly to trigger immediate processing
                $COMPOSE_CMD $COMPOSE_FILES exec -T haarrrvest-publisher python -m app.haarrrvest_publisher.service --once
                ;;
            logs)
                output info "Showing HAARRRvest publisher logs..."
                $COMPOSE_CMD $COMPOSE_FILES logs -f haarrrvest-publisher
                ;;
            status)
                output info "Checking HAARRRvest publisher status..."
                $COMPOSE_CMD $COMPOSE_FILES ps haarrrvest-publisher
                ;;
            *)
                output error "Unknown haarrrvest subcommand: $1"
                output error "Use: haarrrvest [run|logs|status]"
                exit 1
                ;;
        esac
        ;;

    clean)
        output info "Stopping services and removing volumes..."
        if $COMPOSE_CMD $COMPOSE_FILES down -v; then
            output success "Clean complete!"
        else
            output error "Clean failed"
            exit 1
        fi
        ;;

    version)
        echo "⚓ Bouy v$VERSION"
        echo "Docker fleet management for Pantry Pirate Radio"
        echo ""
        echo "Navigate the seas of containers with ease!"
        ;;

    *)
        usage
        exit 1
        ;;
esac