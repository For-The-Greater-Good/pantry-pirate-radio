#!/bin/bash
set -e

# Bouy - Docker fleet management for Pantry Pirate Radio
# Navigate the seas of containers with ease!
#
# Version: 1.0.0
#
COMPOSE_FILES="-f docker-compose.yml"
COMPOSE_CMD="docker compose"
VERSION="1.0.0"

# Default behavior flags
PROGRAMMATIC_MODE=0
VERBOSE=0
QUIET=0
JSON_OUTPUT=0
NO_COLOR=0

# Parse global flags
while [[ $# -gt 0 ]] && [[ "$1" =~ ^-- ]]; do
    case $1 in
        --version|-v)
            echo "⚓ Bouy v$VERSION"
            echo "Docker fleet management for Pantry Pirate Radio"
            exit 0
            ;;
        --programmatic)
            PROGRAMMATIC_MODE=1
            NO_COLOR=1
            shift
            ;;
        --json)
            JSON_OUTPUT=1
            PROGRAMMATIC_MODE=1
            NO_COLOR=1
            shift
            ;;
        --verbose)
            VERBOSE=1
            shift
            ;;
        --quiet)
            QUIET=1
            shift
            ;;
        --no-color)
            NO_COLOR=1
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            break
            ;;
    esac
done

# Output functions for programmatic mode
output() {
    local level="$1"
    local message="$2"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    if [ $QUIET -eq 1 ] && [ "$level" != "error" ] && [ "$level" != "result" ]; then
        return
    fi

    if [ $JSON_OUTPUT -eq 1 ]; then
        # Escape quotes in message for JSON
        message="${message//\"/\\\"}"
        echo "{\"timestamp\":\"$timestamp\",\"level\":\"$level\",\"message\":\"$message\"}"
    elif [ $PROGRAMMATIC_MODE -eq 1 ]; then
        echo "[$timestamp] [$level] $message" >&2
    elif [ "$level" = "result" ]; then
        # Results always go to stdout
        echo "$message"
    else
        # Normal mode - colored output to stderr
        if [ $NO_COLOR -eq 0 ]; then
            case "$level" in
                error)
                    echo -e "\033[31m[ERROR]\033[0m $message" >&2
                    ;;
                warning)
                    echo -e "\033[33m[WARNING]\033[0m $message" >&2
                    ;;
                info)
                    echo -e "\033[34m[INFO]\033[0m $message" >&2
                    ;;
                success)
                    echo -e "\033[32m[SUCCESS]\033[0m $message" >&2
                    ;;
                *)
                    echo "$message" >&2
                    ;;
            esac
        else
            echo "[$level] $message" >&2
        fi
    fi
}

# Helper function to check database schema
check_database_schema() {
    local db_name="${1:-pantry_pirate_radio}"
    output info "Checking database schema in $db_name..."
    
    # Check if record_version table exists (indicates schema is initialized)
    if $COMPOSE_CMD $COMPOSE_FILES exec -T db psql -U postgres -d "$db_name" -c "SELECT 1 FROM record_version LIMIT 1;" >/dev/null 2>&1; then
        output success "Database schema is initialized"
        return 0
    else
        output warning "Database schema not initialized"
        return 1
    fi
}

# Helper function to initialize database schema
init_database_schema() {
    local db_name="${1:-pantry_pirate_radio}"
    output info "Initializing database schema in $db_name..."
    
    for init_script in ./init-scripts/*.sql; do
        if [ -f "$init_script" ]; then
            script_name=$(basename "$init_script")
            output info "Running $script_name..."
            $COMPOSE_CMD $COMPOSE_FILES exec -T db psql -U postgres -d "$db_name" -f "/docker-entrypoint-initdb.d/$script_name" 2>&1 | grep -v "NOTICE:" || true
        fi
    done
    output success "Database schema initialized"
}

# Helper function to check Redis connectivity
check_redis_connectivity() {
    output info "Checking Redis connectivity..."
    
    if $COMPOSE_CMD $COMPOSE_FILES exec -T cache redis-cli ping >/dev/null 2>&1; then
        output success "Redis is accessible"
        return 0
    else
        output error "Redis is not accessible"
        return 1
    fi
}

# Helper function to check if directory exists and is writable
check_directory_writable() {
    local dir_path="$1"
    local service="$2"
    
    output info "Checking directory: $dir_path"
    
    # Check if directory exists in container
    if $COMPOSE_CMD $COMPOSE_FILES exec -T "$service" test -d "$dir_path" 2>/dev/null; then
        # Check if writable
        if $COMPOSE_CMD $COMPOSE_FILES exec -T "$service" test -w "$dir_path" 2>/dev/null; then
            output success "Directory is writable: $dir_path"
            return 0
        else
            output error "Directory is not writable: $dir_path"
            return 1
        fi
    else
        output warning "Directory does not exist: $dir_path"
        # Try to create it
        if $COMPOSE_CMD $COMPOSE_FILES exec -T "$service" mkdir -p "$dir_path" 2>/dev/null; then
            output success "Created directory: $dir_path"
            return 0
        else
            output error "Failed to create directory: $dir_path"
            return 1
        fi
    fi
}

# Helper function to wait for database to be ready
wait_for_database() {
    output info "Waiting for database to be ready..."
    local max_attempts=30
    local attempt=0
    
    while [ $attempt -lt $max_attempts ]; do
        if $COMPOSE_CMD $COMPOSE_FILES exec -T db pg_isready -U postgres >/dev/null 2>&1; then
            output success "Database is ready!"
            return 0
        fi
        attempt=$((attempt + 1))
        if [ $attempt -eq $max_attempts ]; then
            output error "Database failed to become ready"
            return 1
        fi
        echo "Waiting for database... (attempt $attempt/$max_attempts)"
        sleep 2
    done
}

# Helper function to check git configuration
check_git_config() {
    local service="$1"
    output info "Checking git configuration..."
    
    # Check git user.name
    if ! $COMPOSE_CMD $COMPOSE_FILES exec -T "$service" git config --global user.name >/dev/null 2>&1; then
        output warning "Git user.name not set, using default"
        $COMPOSE_CMD $COMPOSE_FILES exec -T "$service" git config --global user.name "Pantry Pirate Radio" || true
    fi
    
    # Check git user.email
    if ! $COMPOSE_CMD $COMPOSE_FILES exec -T "$service" git config --global user.email >/dev/null 2>&1; then
        output warning "Git user.email not set, using default"
        $COMPOSE_CMD $COMPOSE_FILES exec -T "$service" git config --global user.email "pantry-pirate-radio@example.com" || true
    fi
    
    output success "Git configuration verified"
}

# Function to show usage
usage() {
    echo "⚓ Bouy v$VERSION - Docker Fleet Management ⚓"
    echo ""
    echo "Usage: bouy [GLOBAL_OPTIONS] COMMAND [OPTIONS]"
    echo ""
    echo "Global Options:"
    echo "  --programmatic      Enable programmatic mode (structured output)"
    echo "  --json              Output in JSON format (implies --programmatic)"
    echo "  --verbose           Enable verbose output"
    echo "  --quiet             Suppress non-error output"
    echo "  --no-color          Disable colored output"
    echo ""
    echo "Commands:"
    echo "  up [SERVICE]        Start services (dev mode by default)"
    echo "  down                Stop all services"
    echo "  build [SERVICE]     Build services"
    echo "  logs [SERVICE]      View logs (follows by default)"
    echo "  shell SERVICE       Open shell in service container"
    echo "  exec SERVICE CMD    Execute command in service container"
    echo "  ps                  List running services"
    echo "  test [OPTIONS]      Run tests with various options"
    echo "  scraper [NAME|--all] Run specific scraper or all scrapers"
    echo "  scraper-test [NAME] Test scrapers without processing"
    echo "  claude-auth [CMD]   Manage Claude authentication"
    echo "  reconciler [ARGS]   Run the reconciler service"
    echo "  recorder [ARGS]     Run the recorder service"
    echo "  content-store [CMD] Manage content store"
    echo "  haarrrvest [CMD]    Manage HAARRRvest publisher"
    echo "  datasette [CMD]     Export database to SQLite for Datasette"
    echo "  replay [OPTIONS]    Replay recorded JSON files"
    echo "  clean               Stop services and remove volumes"
    echo ""
    echo "Test options:"
    echo "  test                Run all CI checks"
    echo "  test --pytest       Run only pytest"
    echo "  test --mypy         Run only mypy type checking"
    echo "  test --black        Run only black formatting"
    echo "  test --ruff         Run only ruff linting"
    echo "  test --bandit       Run only bandit security check"
    echo "  test --coverage     Run pytest with coverage"
    echo ""
    echo "Scraper options:"
    echo "  scraper --list      List all available scrapers"
    echo "  scraper --all       Run all scrapers"
    echo "  scraper NAME        Run specific scraper by name"
    echo ""
    echo "Claude auth options:"
    echo "  claude-auth         Interactive Claude authentication"
    echo "  claude-auth setup   Setup Claude authentication"
    echo "  claude-auth status  Check authentication status"
    echo "  claude-auth test    Test Claude connection"
    echo "  claude-auth config  Show Claude configuration"
    echo ""
    echo "Content store options:"
    echo "  content-store status      Show content store status"
    echo "  content-store report      Generate detailed report"
    echo "  content-store duplicates  Find duplicate content"
    echo "  content-store efficiency  Analyze storage efficiency"
    echo ""
    echo "HAARRRvest publisher options:"
    echo "  haarrrvest              Manually trigger publishing run"
    echo "  haarrrvest run          Manually trigger publishing run"
    echo "  haarrrvest logs         Follow publisher logs"
    echo "  haarrrvest status       Check publisher service status"
    echo ""
    echo "Datasette options:"
    echo "  datasette              Export database to SQLite immediately"
    echo "  datasette export       Export database to SQLite immediately"
    echo "  datasette schedule     Start periodic export scheduler"
    echo "  datasette status       Check export status and SQLite file"
    echo ""
    echo "Replay options:"
    echo "  replay                          Show replay help"
    echo "  replay --file FILE              Replay single JSON file"
    echo "  replay --directory DIR          Replay all files in directory"
    echo "  replay --use-default-output-dir Use default outputs directory"
    echo "  replay --dry-run               Preview without executing"
    echo ""
    echo "Scraper test options:"
    echo "  scraper-test --all     Test all scrapers (dry run)"
    echo "  scraper-test NAME      Test specific scraper (dry run)"
    echo ""
    echo "Environment modes (use with 'up'):"
    echo "  --dev               Development mode (default)"
    echo "  --prod              Production mode"
    echo "  --test              Test mode"
    echo "  --with-init         Include database initialization"
    echo ""
    echo "Examples:"
    echo "  bouy up                    # Start dev environment"
    echo "  bouy up --prod             # Start production environment"
    echo "  bouy up worker --dev       # Start only worker in dev mode"
    echo "  bouy logs app              # View app logs"
    echo "  bouy shell app             # Open shell in app container"
    echo "  bouy test                  # Run tests"
    echo ""
    echo "Programmatic Examples:"
    echo "  bouy --json ps             # Get service status as JSON"
    echo "  bouy --quiet up            # Start services with minimal output"
    echo "  bouy --programmatic exec app python --version"
    echo ""
    echo "⛵ Smooth sailing with your container fleet!"
}

# Parse environment mode
parse_mode() {
    local mode="dev"
    for arg in "$@"; do
        case $arg in
            --dev)
                mode="dev"
                ;;
            --prod)
                mode="prod"
                ;;
            --test)
                mode="test"
                ;;
            --with-init)
                COMPOSE_FILES="$COMPOSE_FILES -f .docker/compose/docker-compose.with-init.yml"
                ;;
        esac
    done

    case $mode in
        dev)
            COMPOSE_FILES="$COMPOSE_FILES -f .docker/compose/docker-compose.dev.yml"
            ;;
        prod)
            COMPOSE_FILES="$COMPOSE_FILES -f .docker/compose/docker-compose.prod.yml"
            ;;
        test)
            COMPOSE_FILES="$COMPOSE_FILES -f .docker/compose/docker-compose.test.yml"
            ;;
    esac
}

# Main command handling
case "$1" in
    up)
        shift
        parse_mode "$@"
        # Filter out mode flags from service names
        services=""
        for arg in "$@"; do
            case $arg in
                --dev|--prod|--test|--with-init)
                    ;;
                *)
                    services="$services $arg"
                    ;;
            esac
        done

        output info "Starting services with: $COMPOSE_CMD $COMPOSE_FILES"
        # Check if --with-init was used
        if [[ "$COMPOSE_FILES" == *"with-init"* ]]; then
            if $COMPOSE_CMD $COMPOSE_FILES --profile with-init up -d $services; then
                output success "Services started successfully"
            else
                output error "Failed to start services"
                exit 1
            fi
        else
            if $COMPOSE_CMD $COMPOSE_FILES up -d $services; then
                output success "Services started successfully"
            else
                output error "Failed to start services"
                exit 1
            fi
        fi

        # Show status
        if [ $PROGRAMMATIC_MODE -eq 0 ]; then
            echo ""
            $COMPOSE_CMD $COMPOSE_FILES ps
            echo ""
            echo "Services started! Access points:"
            echo "  - API: http://localhost:8000"
            echo "  - API Docs: http://localhost:8000/docs"
            echo "  - Datasette: http://localhost:8001"
            echo "  - RQ Dashboard: http://localhost:9181"
        else
            # In programmatic mode, output JSON with service URLs
            if [ $JSON_OUTPUT -eq 1 ]; then
                echo '{"status":"started","endpoints":{"api":"http://localhost:8000","docs":"http://localhost:8000/docs","datasette":"http://localhost:8001","rq_dashboard":"http://localhost:9181"}}'
            fi
        fi
        ;;

    down)
        output info "Stopping all services..."
        if $COMPOSE_CMD $COMPOSE_FILES down; then
            output success "All services stopped"
        else
            output error "Failed to stop services"
            exit 1
        fi
        ;;

    build)
        shift
        parse_mode "$@"
        services=""
        for arg in "$@"; do
            case $arg in
                --dev|--prod|--test|--with-init)
                    ;;
                *)
                    services="$services $arg"
                    ;;
            esac
        done
        output info "Building services..."
        if $COMPOSE_CMD $COMPOSE_FILES build $services; then
            output success "Build complete"
        else
            output error "Build failed"
            exit 1
        fi
        ;;

    logs)
        shift
        parse_mode "$@"
        service="$1"

        # In programmatic mode, don't follow logs by default
        LOG_FLAGS="-f"
        if [ $PROGRAMMATIC_MODE -eq 1 ]; then
            LOG_FLAGS="--tail 100"
        fi

        if [ -z "$service" ]; then
            $COMPOSE_CMD $COMPOSE_FILES logs $LOG_FLAGS
        else
            $COMPOSE_CMD $COMPOSE_FILES logs $LOG_FLAGS "$service"
        fi
        ;;

    shell)
        shift
        parse_mode "$@"
        service="$1"
        if [ -z "$service" ]; then
            output error "Please specify a service name"
            output error "Example: ./docker.sh shell app"
            exit 1
        fi
        if [ $PROGRAMMATIC_MODE -eq 1 ]; then
            output error "Shell command requires interactive mode. Run without --programmatic flag."
            exit 1
        fi
        $COMPOSE_CMD $COMPOSE_FILES exec "$service" bash || \
        $COMPOSE_CMD $COMPOSE_FILES exec "$service" sh
        ;;

    exec)
        shift
        parse_mode "$@"
        service="$1"
        shift
        if [ -z "$service" ]; then
            output error "Please specify a service name and command"
            output error "Example: ./docker.sh exec app python --version"
            exit 1
        fi
        EXEC_FLAGS=""
        if [ $PROGRAMMATIC_MODE -eq 1 ]; then
            EXEC_FLAGS="-T"
        fi
        $COMPOSE_CMD $COMPOSE_FILES exec $EXEC_FLAGS "$service" "$@"
        ;;

    ps)
        parse_mode "$@"
        if [ $JSON_OUTPUT -eq 1 ]; then
            # Try to use docker compose ps --format json if available
            if $COMPOSE_CMD $COMPOSE_FILES ps --format json 2>/dev/null; then
                :
            else
                # Fallback: parse regular output into JSON
                output warning "JSON format not supported by this docker compose version"
                $COMPOSE_CMD $COMPOSE_FILES ps
            fi
        else
            $COMPOSE_CMD $COMPOSE_FILES ps
        fi
        ;;

    test)
        shift
        test_cmd=""

        # Parse test options
        case "${1:-all}" in
            --pytest)
                test_cmd="poetry run pytest --ignore=docs --ignore=tests/test_integration --cov=app --cov-report=term-missing --cov-report=xml --cov-report=json --cov-branch"
                ;;
            --mypy)
                test_cmd="poetry run mypy app tests"
                ;;
            --black)
                test_cmd="poetry run black app tests"
                ;;
            --ruff)
                test_cmd="poetry run ruff check app tests"
                ;;
            --bandit)
                test_cmd="poetry run bandit -r app"
                ;;
            --coverage)
                test_cmd="poetry run pytest --ignore=docs --ignore=tests/test_integration --cov=app --cov-report=term-missing --cov-report=xml --cov-report=json --cov-branch && bash scripts/coverage-check.sh"
                ;;
            all|"")
                test_cmd="bash scripts/run-ci-checks.sh"
                ;;
            *)
                output error "Unknown test option: $1"
                output error "Use: test [--pytest|--mypy|--black|--ruff|--bandit|--coverage]"
                exit 1
                ;;
        esac

        output info "Running tests with bind-mounted code..."

        # Ensure the test image is built
        if ! docker image inspect pantry-pirate-radio-test:latest &> /dev/null; then
            output info "Building test image..."

            # Use buildx with cache if available
            BUILD_CMD="docker build"
            if command -v docker buildx &> /dev/null; then
                BUILD_CMD="docker buildx build --load"
            fi

            if ! $BUILD_CMD -f .docker/images/app/Dockerfile --target test -t pantry-pirate-radio-test:latest .; then
                output error "Failed to build test image"
                exit 1
            fi
        else
            output info "Test image already exists, skipping build"
        fi

        # Use test environment file
        if [ ! -f .env.test ]; then
            output error ".env.test file not found!"
            output error "Please ensure .env.test exists with proper test database configuration."
            exit 1
        fi

        # Start test services if not already running
        output info "Ensuring test services are running..."

        # Start services
        output info "Starting database and cache services..."
        $COMPOSE_CMD $COMPOSE_FILES up -d db cache

        # Wait for PostgreSQL to be ready
        output info "Waiting for database to be ready..."
        max_attempts=30
        attempt=0
        while [ $attempt -lt $max_attempts ]; do
            if $COMPOSE_CMD $COMPOSE_FILES exec -T db pg_isready -U postgres >/dev/null 2>&1; then
                output info "Database is ready!"
                break
            fi
            attempt=$((attempt + 1))
            if [ $attempt -eq $max_attempts ]; then
                output error "Database failed to become ready"
                $COMPOSE_CMD $COMPOSE_FILES ps
                $COMPOSE_CMD $COMPOSE_FILES logs db --tail 50
                exit 1
            fi
            echo "Waiting for database... (attempt $attempt/$max_attempts)"
            sleep 2
        done

        # Wait for Redis to be ready
        output info "Waiting for cache to be ready..."
        attempt=0
        while [ $attempt -lt $max_attempts ]; do
            if $COMPOSE_CMD $COMPOSE_FILES exec -T cache redis-cli ping >/dev/null 2>&1; then
                output info "Cache is ready!"
                break
            fi
            attempt=$((attempt + 1))
            if [ $attempt -eq $max_attempts ]; then
                output error "Cache failed to become ready"
                $COMPOSE_CMD $COMPOSE_FILES ps
                $COMPOSE_CMD $COMPOSE_FILES logs cache --tail 50
                exit 1
            fi
            echo "Waiting for cache... (attempt $attempt/$max_attempts)"
            sleep 2
        done

        # Create test database
        output info "Creating test database..."
        $COMPOSE_CMD $COMPOSE_FILES exec -T db psql -U postgres -c "CREATE DATABASE test_pantry_pirate_radio;" 2>/dev/null || true

        # Initialize test database schema
        output info "Initializing test database schema..."
        for init_script in ./init-scripts/*.sql; do
            if [ -f "$init_script" ]; then
                script_name=$(basename "$init_script")
                output info "Running $script_name on test database..."
                $COMPOSE_CMD $COMPOSE_FILES exec -T db psql -U postgres -d test_pantry_pirate_radio -f "/docker-entrypoint-initdb.d/$script_name" 2>&1 | grep -v "NOTICE:" || true
            fi
        done

        # Check if we're in a TTY (disable TTY in programmatic mode)
        TTY_FLAG=""
        if [ -t 0 ] && [ $PROGRAMMATIC_MODE -eq 0 ]; then
            TTY_FLAG="-it"
        fi

        # Get the network name
        NETWORK_NAME="${COMPOSE_PROJECT_NAME:-pantry-pirate-radio}_default"

        # Run tests in a temporary container with current code mounted
        docker run --rm $TTY_FLAG \
            -v $(pwd):/app:cached \
            -w /app \
            --network "$NETWORK_NAME" \
            --env-file .env.test \
            -e TEST_DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD:-pirate}@db:5432/test_pantry_pirate_radio \
            -e TEST_REDIS_URL=redis://cache:6379/1 \
            pantry-pirate-radio-test:latest \
            bash -c "$test_cmd"
        ;;

    scraper)
        shift
        parse_mode "$@"

        # Ensure cache is running for job queue
        if ! $COMPOSE_CMD $COMPOSE_FILES ps cache 2>/dev/null | grep -q "Up"; then
            output info "Cache service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d cache; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start cache service"
                exit 1
            fi
        fi

        # Check Redis connectivity
        if ! check_redis_connectivity; then
            output error "Redis is required for scraper job queue"
            exit 1
        fi

        # Check if scraper service is running
        if ! $COMPOSE_CMD $COMPOSE_FILES ps scraper 2>/dev/null | grep -q "Up"; then
            output info "Scraper service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d scraper; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start scraper service"
                exit 1
            fi
        fi

        # Check content store if enabled
        if $COMPOSE_CMD $COMPOSE_FILES exec -T scraper printenv CONTENT_STORE_ENABLED 2>/dev/null | grep -q "true"; then
            output info "Content store is enabled, checking configuration..."
            if ! $COMPOSE_CMD $COMPOSE_FILES exec -T scraper test -d "/data-repo/content-store" 2>/dev/null; then
                output warning "Content store directory not found - deduplication may not work"
            else
                output success "Content store directory found"
            fi
        fi

        # Parse scraper options
        case "${1:-help}" in
            --list)
                output info "Listing available scrapers..."
                # Use -T flag to disable TTY in programmatic mode
                EXEC_FLAGS=""
                if [ $PROGRAMMATIC_MODE -eq 1 ]; then
                    EXEC_FLAGS="-T"
                fi
                $COMPOSE_CMD $COMPOSE_FILES exec $EXEC_FLAGS scraper python -m app.scraper --list
                ;;
            --all)
                output info "Running all scrapers..."
                EXEC_FLAGS=""
                if [ $PROGRAMMATIC_MODE -eq 1 ]; then
                    EXEC_FLAGS="-T"
                fi
                $COMPOSE_CMD $COMPOSE_FILES exec $EXEC_FLAGS scraper python -m app.scraper --all
                ;;
            help|"")
                if [ $PROGRAMMATIC_MODE -eq 0 ]; then
                    echo "Usage: ./docker.sh scraper [--list|--all|SCRAPER_NAME]"
                    echo ""
                    echo "Available scrapers:"
                    $COMPOSE_CMD $COMPOSE_FILES exec scraper python -m app.scraper --list
                else
                    output error "No scraper command specified. Use --list, --all, or provide a scraper name."
                    exit 1
                fi
                ;;
            *)
                # Filter out mode flags
                scraper_name=""
                for arg in "$@"; do
                    case $arg in
                        --dev|--prod|--test|--with-init)
                            ;;
                        *)
                            scraper_name="$arg"
                            break
                            ;;
                    esac
                done

                if [ -n "$scraper_name" ]; then
                    output info "Running scraper: $scraper_name"
                    EXEC_FLAGS=""
                    if [ $PROGRAMMATIC_MODE -eq 1 ]; then
                        EXEC_FLAGS="-T"
                    fi
                    $COMPOSE_CMD $COMPOSE_FILES exec $EXEC_FLAGS scraper python -m app.scraper "$scraper_name"
                else
                    output error "No scraper name provided"
                    exit 1
                fi
                ;;
        esac
        ;;

    claude-auth)
        shift
        parse_mode "$@"

        # Check if worker service is running
        if ! $COMPOSE_CMD $COMPOSE_FILES ps worker 2>/dev/null | grep -q "Up"; then
            output info "Worker service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d worker; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start worker service"
                exit 1
            fi
        fi

        # Parse subcommand
        case "${1:-interactive}" in
            interactive|"")
                if [ $PROGRAMMATIC_MODE -eq 1 ]; then
                    output error "Claude authentication requires interactive mode. Run without --programmatic flag."
                    exit 1
                fi
                output info "Authenticating Claude in worker container..."
                output info "This will open an interactive Claude authentication session."
                echo ""
                $COMPOSE_CMD $COMPOSE_FILES exec worker claude
                ;;
            setup)
                output info "Setting up Claude authentication..."
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.claude_auth_manager setup
                ;;
            status)
                output info "Checking Claude authentication status..."
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.claude_auth_manager status
                ;;
            test)
                output info "Testing Claude authentication..."
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.claude_auth_manager test
                ;;
            config)
                output info "Showing Claude configuration..."
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.claude_auth_manager config
                ;;
            *)
                output error "Unknown claude-auth subcommand: $1"
                output error "Use: claude-auth [interactive|setup|status|test|config]"
                exit 1
                ;;
        esac
        ;;

    reconciler)
        shift
        parse_mode "$@"

        # Ensure database is running
        if ! $COMPOSE_CMD $COMPOSE_FILES ps db 2>/dev/null | grep -q "Up"; then
            output info "Database service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d db; then
                wait_for_database || exit 1
            else
                output error "Failed to start database service"
                exit 1
            fi
        fi

        # Check database schema
        if ! check_database_schema; then
            output info "Database schema needs initialization"
            init_database_schema || exit 1
        fi

        # Check if reconciler service is running
        if ! $COMPOSE_CMD $COMPOSE_FILES ps reconciler 2>/dev/null | grep -q "Up"; then
            output info "Reconciler service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d reconciler; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start reconciler service"
                exit 1
            fi
        fi

        # Build command
        cmd="python -m app.reconciler"
        for arg in "$@"; do
            case $arg in
                --dev|--prod|--test|--with-init)
                    ;;
                *)
                    cmd="$cmd $arg"
                    ;;
            esac
        done

        output info "Running reconciler..."
        EXEC_FLAGS=""
        if [ $PROGRAMMATIC_MODE -eq 1 ]; then
            EXEC_FLAGS="-T"
        fi
        $COMPOSE_CMD $COMPOSE_FILES exec $EXEC_FLAGS reconciler bash -c "$cmd"
        ;;

    recorder)
        shift
        parse_mode "$@"

        # Ensure cache is running for job queue
        if ! $COMPOSE_CMD $COMPOSE_FILES ps cache 2>/dev/null | grep -q "Up"; then
            output info "Cache service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d cache; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start cache service"
                exit 1
            fi
        fi

        # Check Redis connectivity
        if ! check_redis_connectivity; then
            output error "Redis is required for recorder job queue"
            exit 1
        fi

        # Check if recorder service is running
        if ! $COMPOSE_CMD $COMPOSE_FILES ps recorder 2>/dev/null | grep -q "Up"; then
            output info "Recorder service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d recorder; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start recorder service"
                exit 1
            fi
        fi

        # Check output directory
        check_directory_writable "/app/outputs" "recorder" || output warning "Output directory may not be writable"

        # Build command
        cmd="python -m app.recorder"
        for arg in "$@"; do
            case $arg in
                --dev|--prod|--test|--with-init)
                    ;;
                *)
                    cmd="$cmd $arg"
                    ;;
            esac
        done

        output info "Running recorder..."
        EXEC_FLAGS=""
        if [ $PROGRAMMATIC_MODE -eq 1 ]; then
            EXEC_FLAGS="-T"
        fi
        $COMPOSE_CMD $COMPOSE_FILES exec $EXEC_FLAGS recorder bash -c "$cmd"
        ;;

    content-store)
        shift
        parse_mode "$@"

        # Content store commands run in worker container
        if ! $COMPOSE_CMD $COMPOSE_FILES ps worker 2>/dev/null | grep -q "Up"; then
            output info "Worker service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d worker; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start worker service"
                exit 1
            fi
        fi

        # Check content store directory in data repo
        output info "Checking content store configuration..."
        
        # Check if content store directory exists
        if ! $COMPOSE_CMD $COMPOSE_FILES exec -T worker test -d "/data-repo/content-store" 2>/dev/null; then
            output warning "Content store directory not found in data repo"
            output info "Content store may be disabled or not yet initialized"
        else
            output success "Content store directory found"
            
            # Check for SQLite database
            if $COMPOSE_CMD $COMPOSE_FILES exec -T worker test -f "/data-repo/content-store/index.db" 2>/dev/null; then
                output success "Content store SQLite database found"
            else
                output warning "Content store SQLite database not found - will be created on first use"
            fi
        fi

        # Parse subcommand
        subcmd="${1:-status}"
        shift || true

        case "$subcmd" in
            status)
                output info "Checking content store status..."
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.content_store status
                ;;
            report)
                output info "Generating content store report..."
                # Pass through any additional arguments
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.content_store report "$@"
                ;;
            duplicates)
                output info "Finding content store duplicates..."
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.content_store duplicates
                ;;
            efficiency)
                output info "Analyzing content store efficiency..."
                $COMPOSE_CMD $COMPOSE_FILES exec -T worker python -m app.content_store efficiency
                ;;
            *)
                output error "Unknown content-store subcommand: $subcmd"
                output error "Use: content-store [status|report|duplicates|efficiency]"
                exit 1
                ;;
        esac
        ;;

    haarrrvest|publisher)
        shift
        parse_mode "$@"

        # Ensure database is running for data export
        if ! $COMPOSE_CMD $COMPOSE_FILES ps db 2>/dev/null | grep -q "Up"; then
            output info "Database service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d db; then
                wait_for_database || exit 1
            else
                output error "Failed to start database service"
                exit 1
            fi
        fi

        # Check database schema
        if ! check_database_schema; then
            output info "Database schema needs initialization"
            init_database_schema || exit 1
        fi

        # Check if haarrrvest-publisher service is running
        if ! $COMPOSE_CMD $COMPOSE_FILES ps haarrrvest-publisher 2>/dev/null | grep -q "Up"; then
            output info "HAARRRvest publisher service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d haarrrvest-publisher; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start HAARRRvest publisher service"
                exit 1
            fi
        fi

        # Check git configuration
        check_git_config "haarrrvest-publisher"

        # Check if HAARRRvest repository is initialized
        output info "Checking HAARRRvest repository..."
        if ! $COMPOSE_CMD $COMPOSE_FILES exec -T haarrrvest-publisher test -d "/data-repo/.git" 2>/dev/null; then
            output warning "HAARRRvest repository not initialized"
            output info "The publisher service will clone the repository on first run"
        else
            output success "HAARRRvest repository found"
        fi

        # Check output directory
        if ! $COMPOSE_CMD $COMPOSE_FILES exec -T haarrrvest-publisher test -d "/app/outputs" 2>/dev/null; then
            output warning "Output directory not found - no files to publish"
        fi

        # Parse subcommand
        case "${1:-run}" in
            run|"")
                output info "Manually triggering HAARRRvest publisher..."
                output info "This will process all pending recorder outputs and push to HAARRRvest repository."
                # Run the publisher module directly to trigger immediate processing
                $COMPOSE_CMD $COMPOSE_FILES exec -T haarrrvest-publisher python -m app.haarrrvest_publisher.service --once
                ;;
            logs)
                output info "Showing HAARRRvest publisher logs..."
                $COMPOSE_CMD $COMPOSE_FILES logs -f haarrrvest-publisher
                ;;
            status)
                output info "Checking HAARRRvest publisher status..."
                $COMPOSE_CMD $COMPOSE_FILES ps haarrrvest-publisher
                ;;
            *)
                output error "Unknown haarrrvest subcommand: $1"
                output error "Use: haarrrvest [run|logs|status]"
                exit 1
                ;;
        esac
        ;;

    datasette)
        shift
        parse_mode "$@"

        # Ensure database is running for export
        if ! $COMPOSE_CMD $COMPOSE_FILES ps db 2>/dev/null | grep -q "Up"; then
            output info "Database service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d db; then
                wait_for_database || exit 1
            else
                output error "Failed to start database service"
                exit 1
            fi
        fi

        # Check database schema
        if ! check_database_schema; then
            output error "Database schema must be initialized before export"
            exit 1
        fi

        # Check if datasette-exporter service is running
        if ! $COMPOSE_CMD $COMPOSE_FILES ps datasette-exporter 2>/dev/null | grep -q "Up"; then
            output info "Datasette exporter service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d datasette-exporter; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start datasette exporter service"
                exit 1
            fi
        fi

        # Parse subcommand
        case "${1:-export}" in
            export|"")
                output info "Exporting database to SQLite for Datasette..."
                # Run the export directly
                $COMPOSE_CMD $COMPOSE_FILES exec -T datasette-exporter python -m app.datasette export
                ;;
            schedule)
                output info "Starting Datasette export scheduler..."
                output info "Exports will run periodically based on EXPORT_INTERVAL setting"
                $COMPOSE_CMD $COMPOSE_FILES exec datasette-exporter python -m app.datasette schedule
                ;;
            status)
                output info "Checking Datasette exporter status..."
                $COMPOSE_CMD $COMPOSE_FILES ps datasette-exporter
                # Check if SQLite file exists
                if $COMPOSE_CMD $COMPOSE_FILES exec -T datasette-exporter test -f "/data/latest.sqlite" 2>/dev/null; then
                    output success "Latest SQLite export found"
                else
                    output warning "No SQLite export found yet"
                fi
                ;;
            *)
                output error "Unknown datasette subcommand: $1"
                output error "Use: datasette [export|schedule|status]"
                exit 1
                ;;
        esac
        ;;

    replay)
        shift
        parse_mode "$@"

        # Ensure database is running for replay
        if ! $COMPOSE_CMD $COMPOSE_FILES ps db 2>/dev/null | grep -q "Up"; then
            output info "Database service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d db; then
                wait_for_database || exit 1
            else
                output error "Failed to start database service"
                exit 1
            fi
        fi

        # Check database schema
        if ! check_database_schema; then
            output error "Database schema must be initialized before replay"
            exit 1
        fi

        # Ensure cache is running
        if ! $COMPOSE_CMD $COMPOSE_FILES ps cache 2>/dev/null | grep -q "Up"; then
            output info "Cache service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d cache; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start cache service"
                exit 1
            fi
        fi

        # Use worker container for replay since it has all dependencies
        if ! $COMPOSE_CMD $COMPOSE_FILES ps worker 2>/dev/null | grep -q "Up"; then
            output info "Worker service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d worker; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start worker service"
                exit 1
            fi
        fi

        # Build replay command
        cmd="python -m app.replay"
        
        # Parse replay options
        for arg in "$@"; do
            case $arg in
                --dev|--prod|--test|--with-init)
                    ;;
                *)
                    cmd="$cmd $arg"
                    ;;
            esac
        done

        # If no args provided, show help
        if [ "$#" -eq 0 ]; then
            output info "Replay recorded JSON files to recreate database records"
            output info ""
            output info "Usage: bouy replay [OPTIONS]"
            output info "  --file FILE         Replay a single JSON file"
            output info "  --directory DIR     Replay all JSON files in directory"
            output info "  --use-default-output-dir  Use default outputs directory"
            output info "  --pattern PATTERN   File pattern (default: *.json)"
            output info "  --dry-run          Show what would be done without executing"
            output info ""
            output info "Example: bouy replay --use-default-output-dir --dry-run"
        else
            output info "Running replay..."
            EXEC_FLAGS=""
            if [ $PROGRAMMATIC_MODE -eq 1 ]; then
                EXEC_FLAGS="-T"
            fi
            $COMPOSE_CMD $COMPOSE_FILES exec $EXEC_FLAGS worker bash -c "$cmd"
        fi
        ;;

    scraper-test)
        shift
        parse_mode "$@"

        # Check if scraper service is running
        if ! $COMPOSE_CMD $COMPOSE_FILES ps scraper 2>/dev/null | grep -q "Up"; then
            output info "Scraper service is not running. Starting it..."
            if $COMPOSE_CMD $COMPOSE_FILES up -d scraper; then
                sleep 2  # Give it a moment to start
            else
                output error "Failed to start scraper service"
                exit 1
            fi
        fi

        # Parse test options
        case "${1:-help}" in
            --all)
                output info "Testing all scrapers (dry run)..."
                EXEC_FLAGS=""
                if [ $PROGRAMMATIC_MODE -eq 1 ]; then
                    EXEC_FLAGS="-T"
                fi
                $COMPOSE_CMD $COMPOSE_FILES exec $EXEC_FLAGS scraper python -m app.scraper.test_scrapers --all
                ;;
            help|"")
                if [ $PROGRAMMATIC_MODE -eq 0 ]; then
                    echo "Usage: bouy scraper-test [--all|SCRAPER_NAME]"
                    echo ""
                    echo "Test scrapers without processing results"
                    echo "This runs scrapers in dry-run mode to verify they work"
                else
                    output error "No scraper test command specified. Use --all or provide a scraper name."
                    exit 1
                fi
                ;;
            *)
                # Test specific scraper
                scraper_name=""
                for arg in "$@"; do
                    case $arg in
                        --dev|--prod|--test|--with-init)
                            ;;
                        *)
                            scraper_name="$arg"
                            break
                            ;;
                    esac
                done

                if [ -n "$scraper_name" ]; then
                    output info "Testing scraper: $scraper_name"
                    EXEC_FLAGS=""
                    if [ $PROGRAMMATIC_MODE -eq 1 ]; then
                        EXEC_FLAGS="-T"
                    fi
                    $COMPOSE_CMD $COMPOSE_FILES exec $EXEC_FLAGS scraper python -m app.scraper.test_scrapers "$scraper_name"
                else
                    output error "No scraper name provided"
                    exit 1
                fi
                ;;
        esac
        ;;

    clean)
        output info "Stopping services and removing volumes..."
        if $COMPOSE_CMD $COMPOSE_FILES down -v; then
            output success "Clean complete!"
        else
            output error "Clean failed"
            exit 1
        fi
        ;;

    version)
        echo "⚓ Bouy v$VERSION"
        echo "Docker fleet management for Pantry Pirate Radio"
        echo ""
        echo "Navigate the seas of containers with ease!"
        ;;

    *)
        usage
        exit 1
        ;;
esac